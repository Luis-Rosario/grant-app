/* tslint:disable */
/* eslint-disable */
/**
 * GRANT APPLICATION API
 * Grant application management system.
 *
 * The version of the OpenAPI document: 0.9
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface ApplicationDTO
 */
export interface ApplicationDTO {
    /**
     *
     * @type {number}
     * @memberof ApplicationDTO
     */
    applicationID: number;
    /**
     *
     * @type {number}
     * @memberof ApplicationDTO
     */
    grantID: number;
    /**
     *
     * @type {Array<GrantResponse>}
     * @memberof ApplicationDTO
     */
    responses: Array<GrantResponse>;
    /**
     *
     * @type {Array<EvaluationDTO>}
     * @memberof ApplicationDTO
     */
    reviews: Array<EvaluationDTO>;
    /**
     *
     * @type {string}
     * @memberof ApplicationDTO
     */
    status: ApplicationDTOStatusEnum;
    /**
     *
     * @type {number}
     * @memberof ApplicationDTO
     */
    studentID: number;
    /**
     *
     * @type {string}
     * @memberof ApplicationDTO
     */
    submissionDate: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ApplicationDTOStatusEnum {
    Draft = 'DRAFT',
    Granted = 'GRANTED',
    NotGranted = 'NOT_GRANTED',
    Submitted = 'SUBMITTED'
}

/**
 *
 * @export
 * @interface ApplicationDTOReq
 */
export interface ApplicationDTOReq {
    /**
     *
     * @type {number}
     * @memberof ApplicationDTOReq
     */
    applicationID?: number;
    /**
     *
     * @type {number}
     * @memberof ApplicationDTOReq
     */
    grantID?: number;
    /**
     *
     * @type {Array<GrantResponseReq>}
     * @memberof ApplicationDTOReq
     */
    responses: Array<GrantResponseReq>;
    /**
     *
     * @type {Array<EvaluationDTOReq>}
     * @memberof ApplicationDTOReq
     */
    reviews: Array<EvaluationDTOReq>;
    /**
     *
     * @type {string}
     * @memberof ApplicationDTOReq
     */
    status: ApplicationDTOReqStatusEnum;
    /**
     *
     * @type {number}
     * @memberof ApplicationDTOReq
     */
    studentID?: number;
    /**
     *
     * @type {string}
     * @memberof ApplicationDTOReq
     */
    submissionDate: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ApplicationDTOReqStatusEnum {
    Draft = 'DRAFT',
    Granted = 'GRANTED',
    NotGranted = 'NOT_GRANTED',
    Submitted = 'SUBMITTED'
}

/**
 *
 * @export
 * @interface ApplicationDTORes
 */
export interface ApplicationDTORes {
    /**
     *
     * @type {number}
     * @memberof ApplicationDTORes
     */
    applicationID: number;
    /**
     *
     * @type {number}
     * @memberof ApplicationDTORes
     */
    grantID: number;
    /**
     *
     * @type {Array<GrantResponseRes>}
     * @memberof ApplicationDTORes
     */
    responses: Array<GrantResponseRes>;
    /**
     *
     * @type {Array<EvaluationDTORes>}
     * @memberof ApplicationDTORes
     */
    reviews: Array<EvaluationDTORes>;
    /**
     *
     * @type {string}
     * @memberof ApplicationDTORes
     */
    status: ApplicationDTOResStatusEnum;
    /**
     *
     * @type {number}
     * @memberof ApplicationDTORes
     */
    studentID: number;
    /**
     *
     * @type {string}
     * @memberof ApplicationDTORes
     */
    submissionDate: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ApplicationDTOResStatusEnum {
    Draft = 'DRAFT',
    Granted = 'GRANTED',
    NotGranted = 'NOT_GRANTED',
    Submitted = 'SUBMITTED'
}

/**
 *
 * @export
 * @interface ApplicationSafeDTO
 */
export interface ApplicationSafeDTO {
    /**
     *
     * @type {number}
     * @memberof ApplicationSafeDTO
     */
    applicationID: number;
    /**
     *
     * @type {number}
     * @memberof ApplicationSafeDTO
     */
    grantID: number;
    /**
     *
     * @type {Array<EvaluationDTO>}
     * @memberof ApplicationSafeDTO
     */
    reviews: Array<EvaluationDTO>;
    /**
     *
     * @type {string}
     * @memberof ApplicationSafeDTO
     */
    status: ApplicationSafeDTOStatusEnum;
    /**
     *
     * @type {number}
     * @memberof ApplicationSafeDTO
     */
    studentID: number;
    /**
     *
     * @type {string}
     * @memberof ApplicationSafeDTO
     */
    submissionDate: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ApplicationSafeDTOStatusEnum {
    Draft = 'DRAFT',
    Granted = 'GRANTED',
    NotGranted = 'NOT_GRANTED',
    Submitted = 'SUBMITTED'
}

/**
 *
 * @export
 * @interface CVReq
 */
export interface CVReq {
    /**
     *
     * @type {Array<FieldReq>}
     * @memberof CVReq
     */
    fields: Array<FieldReq>;
    /**
     *
     * @type {number}
     * @memberof CVReq
     */
    id?: number;
}
/**
 *
 * @export
 * @interface CVRes
 */
export interface CVRes {
    /**
     *
     * @type {Array<FieldRes>}
     * @memberof CVRes
     */
    fields: Array<FieldRes>;
    /**
     *
     * @type {number}
     * @memberof CVRes
     */
    id: number;
}
/**
 *
 * @export
 * @interface EvaluationDTO
 */
export interface EvaluationDTO {
    /**
     *
     * @type {number}
     * @memberof EvaluationDTO
     */
    applicationId: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTO
     */
    grantId: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTO
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTO
     */
    revId: number;
    /**
     *
     * @type {boolean}
     * @memberof EvaluationDTO
     */
    status: boolean;
    /**
     *
     * @type {string}
     * @memberof EvaluationDTO
     */
    textField: string;
}
/**
 *
 * @export
 * @interface EvaluationDTOReq
 */
export interface EvaluationDTOReq {
    /**
     *
     * @type {number}
     * @memberof EvaluationDTOReq
     */
    applicationId?: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTOReq
     */
    grantId?: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTOReq
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTOReq
     */
    revId?: number;
    /**
     *
     * @type {boolean}
     * @memberof EvaluationDTOReq
     */
    status?: boolean;
    /**
     *
     * @type {string}
     * @memberof EvaluationDTOReq
     */
    textField: string;
}
/**
 *
 * @export
 * @interface EvaluationDTORes
 */
export interface EvaluationDTORes {
    /**
     *
     * @type {number}
     * @memberof EvaluationDTORes
     */
    applicationId: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTORes
     */
    grantId: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTORes
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof EvaluationDTORes
     */
    revId: number;
    /**
     *
     * @type {boolean}
     * @memberof EvaluationDTORes
     */
    status: boolean;
    /**
     *
     * @type {string}
     * @memberof EvaluationDTORes
     */
    textField: string;
}
/**
 *
 * @export
 * @interface FieldReq
 */
export interface FieldReq {
    /**
     *
     * @type {string}
     * @memberof FieldReq
     */
    content: string;
    /**
     *
     * @type {boolean}
     * @memberof FieldReq
     */
    mandatory?: boolean;
    /**
     *
     * @type {string}
     * @memberof FieldReq
     */
    type: string;
}
/**
 *
 * @export
 * @interface FieldRes
 */
export interface FieldRes {
    /**
     *
     * @type {string}
     * @memberof FieldRes
     */
    content: string;
    /**
     *
     * @type {boolean}
     * @memberof FieldRes
     */
    mandatory: boolean;
    /**
     *
     * @type {string}
     * @memberof FieldRes
     */
    type: string;
}
/**
 *
 * @export
 * @interface GrantDTOReq
 */
export interface GrantDTOReq {
    /**
     *
     * @type {Array<GrantQuestionReq>}
     * @memberof GrantDTOReq
     */
    applicationQuestions: Array<GrantQuestionReq>;
    /**
     *
     * @type {number}
     * @memberof GrantDTOReq
     */
    applications?: number;
    /**
     *
     * @type {string}
     * @memberof GrantDTOReq
     */
    deadline: string;
    /**
     *
     * @type {string}
     * @memberof GrantDTOReq
     */
    description: string;
    /**
     *
     * @type {number}
     * @memberof GrantDTOReq
     */
    funding?: number;
    /**
     *
     * @type {number}
     * @memberof GrantDTOReq
     */
    grantId?: number;
    /**
     *
     * @type {string}
     * @memberof GrantDTOReq
     */
    openingDate: string;
    /**
     *
     * @type {number}
     * @memberof GrantDTOReq
     */
    sponsorId?: number;
    /**
     *
     * @type {string}
     * @memberof GrantDTOReq
     */
    sponsorName: string;
    /**
     *
     * @type {string}
     * @memberof GrantDTOReq
     */
    title: string;
}
/**
 *
 * @export
 * @interface GrantDTORes
 */
export interface GrantDTORes {
    /**
     *
     * @type {Array<GrantQuestionRes>}
     * @memberof GrantDTORes
     */
    applicationQuestions: Array<GrantQuestionRes>;
    /**
     *
     * @type {number}
     * @memberof GrantDTORes
     */
    applications: number;
    /**
     *
     * @type {string}
     * @memberof GrantDTORes
     */
    deadline: string;
    /**
     *
     * @type {string}
     * @memberof GrantDTORes
     */
    description: string;
    /**
     *
     * @type {number}
     * @memberof GrantDTORes
     */
    funding: number;
    /**
     *
     * @type {number}
     * @memberof GrantDTORes
     */
    grantId: number;
    /**
     *
     * @type {string}
     * @memberof GrantDTORes
     */
    openingDate: string;
    /**
     *
     * @type {number}
     * @memberof GrantDTORes
     */
    sponsorId: number;
    /**
     *
     * @type {string}
     * @memberof GrantDTORes
     */
    sponsorName: string;
    /**
     *
     * @type {string}
     * @memberof GrantDTORes
     */
    title: string;
}
/**
 *
 * @export
 * @interface GrantQuestion
 */
export interface GrantQuestion {
    /**
     *
     * @type {string}
     * @memberof GrantQuestion
     */
    fieldDescription: string;
    /**
     *
     * @type {boolean}
     * @memberof GrantQuestion
     */
    mandatory: boolean;
    /**
     *
     * @type {string}
     * @memberof GrantQuestion
     */
    type: string;
}
/**
 *
 * @export
 * @interface GrantQuestionReq
 */
export interface GrantQuestionReq {
    /**
     *
     * @type {string}
     * @memberof GrantQuestionReq
     */
    fieldDescription: string;
    /**
     *
     * @type {boolean}
     * @memberof GrantQuestionReq
     */
    mandatory?: boolean;
    /**
     *
     * @type {string}
     * @memberof GrantQuestionReq
     */
    type: string;
}
/**
 *
 * @export
 * @interface GrantQuestionRes
 */
export interface GrantQuestionRes {
    /**
     *
     * @type {string}
     * @memberof GrantQuestionRes
     */
    fieldDescription: string;
    /**
     *
     * @type {boolean}
     * @memberof GrantQuestionRes
     */
    mandatory: boolean;
    /**
     *
     * @type {string}
     * @memberof GrantQuestionRes
     */
    type: string;
}
/**
 *
 * @export
 * @interface GrantResponse
 */
export interface GrantResponse {
    /**
     *
     * @type {GrantQuestion}
     * @memberof GrantResponse
     */
    question: GrantQuestion;
    /**
     *
     * @type {string}
     * @memberof GrantResponse
     */
    response: string;
}
/**
 *
 * @export
 * @interface GrantResponseReq
 */
export interface GrantResponseReq {
    /**
     *
     * @type {GrantQuestionReq}
     * @memberof GrantResponseReq
     */
    question: GrantQuestionReq;
    /**
     *
     * @type {string}
     * @memberof GrantResponseReq
     */
    response: string;
}
/**
 *
 * @export
 * @interface GrantResponseRes
 */
export interface GrantResponseRes {
    /**
     *
     * @type {GrantQuestionRes}
     * @memberof GrantResponseRes
     */
    question: GrantQuestionRes;
    /**
     *
     * @type {string}
     * @memberof GrantResponseRes
     */
    response: string;
}
/**
 *
 * @export
 * @interface IdAndName
 */
export interface IdAndName {
    /**
     *
     * @type {number}
     * @memberof IdAndName
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof IdAndName
     */
    name: string;
}
/**
 *
 * @export
 * @interface IdAndNameReq
 */
export interface IdAndNameReq {
    /**
     *
     * @type {number}
     * @memberof IdAndNameReq
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof IdAndNameReq
     */
    name: string;
}
/**
 *
 * @export
 * @interface IdAndNameRes
 */
export interface IdAndNameRes {
    /**
     *
     * @type {number}
     * @memberof IdAndNameRes
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof IdAndNameRes
     */
    name: string;
}
/**
 *
 * @export
 * @interface InstitutionDTOReq
 */
export interface InstitutionDTOReq {
    /**
     *
     * @type {string}
     * @memberof InstitutionDTOReq
     */
    email: string;
    /**
     *
     * @type {number}
     * @memberof InstitutionDTOReq
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof InstitutionDTOReq
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof InstitutionDTOReq
     */
    phoneNumb: string;
}
/**
 *
 * @export
 * @interface InstitutionDTORes
 */
export interface InstitutionDTORes {
    /**
     *
     * @type {string}
     * @memberof InstitutionDTORes
     */
    email: string;
    /**
     *
     * @type {number}
     * @memberof InstitutionDTORes
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof InstitutionDTORes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof InstitutionDTORes
     */
    phoneNumb: string;
}
/**
 *
 * @export
 * @interface PanelDTO
 */
export interface PanelDTO {
    /**
     *
     * @type {number}
     * @memberof PanelDTO
     */
    grant: number;
    /**
     *
     * @type {number}
     * @memberof PanelDTO
     */
    panelChair: number;
    /**
     *
     * @type {number}
     * @memberof PanelDTO
     */
    panelID: number;
    /**
     *
     * @type {Array<IdAndName>}
     * @memberof PanelDTO
     */
    reviewer: Array<IdAndName>;
}
/**
 *
 * @export
 * @interface PanelDTOReq
 */
export interface PanelDTOReq {
    /**
     *
     * @type {number}
     * @memberof PanelDTOReq
     */
    grant?: number;
    /**
     *
     * @type {number}
     * @memberof PanelDTOReq
     */
    panelChair?: number;
    /**
     *
     * @type {number}
     * @memberof PanelDTOReq
     */
    panelID?: number;
    /**
     *
     * @type {Array<IdAndNameReq>}
     * @memberof PanelDTOReq
     */
    reviewer: Array<IdAndNameReq>;
}
/**
 *
 * @export
 * @interface PanelDTORes
 */
export interface PanelDTORes {
    /**
     *
     * @type {number}
     * @memberof PanelDTORes
     */
    grant: number;
    /**
     *
     * @type {number}
     * @memberof PanelDTORes
     */
    panelChair: number;
    /**
     *
     * @type {number}
     * @memberof PanelDTORes
     */
    panelID: number;
    /**
     *
     * @type {Array<IdAndNameRes>}
     * @memberof PanelDTORes
     */
    reviewer: Array<IdAndNameRes>;
}
/**
 *
 * @export
 * @interface ReviewerDTOReq
 */
export interface ReviewerDTOReq {
    /**
     *
     * @type {string}
     * @memberof ReviewerDTOReq
     */
    address: string;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTOReq
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTOReq
     */
    email: string;
    /**
     *
     * @type {Array<number>}
     * @memberof ReviewerDTOReq
     */
    evals: Array<number>;
    /**
     *
     * @type {number}
     * @memberof ReviewerDTOReq
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof ReviewerDTOReq
     */
    institutionId?: number;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTOReq
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTOReq
     */
    password: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ReviewerDTOReq
     */
    roles: Array<string>;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTOReq
     */
    username: string;
}
/**
 *
 * @export
 * @interface ReviewerDTORes
 */
export interface ReviewerDTORes {
    /**
     *
     * @type {string}
     * @memberof ReviewerDTORes
     */
    address: string;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTORes
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTORes
     */
    email: string;
    /**
     *
     * @type {Array<number>}
     * @memberof ReviewerDTORes
     */
    evals: Array<number>;
    /**
     *
     * @type {number}
     * @memberof ReviewerDTORes
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof ReviewerDTORes
     */
    institutionId: number;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTORes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTORes
     */
    password: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ReviewerDTORes
     */
    roles: Array<string>;
    /**
     *
     * @type {string}
     * @memberof ReviewerDTORes
     */
    username: string;
}
/**
 *
 * @export
 * @interface RoleDTOReq
 */
export interface RoleDTOReq {
    /**
     *
     * @type {number}
     * @memberof RoleDTOReq
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof RoleDTOReq
     */
    role: string;
}
/**
 *
 * @export
 * @interface RoleDTORes
 */
export interface RoleDTORes {
    /**
     *
     * @type {number}
     * @memberof RoleDTORes
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof RoleDTORes
     */
    role: string;
}
/**
 *
 * @export
 * @interface SafeGrantDTO
 */
export interface SafeGrantDTO {
    /**
     *
     * @type {Array<GrantQuestion>}
     * @memberof SafeGrantDTO
     */
    applicationQuestions: Array<GrantQuestion>;
    /**
     *
     * @type {string}
     * @memberof SafeGrantDTO
     */
    deadline: string;
    /**
     *
     * @type {string}
     * @memberof SafeGrantDTO
     */
    description: string;
    /**
     *
     * @type {number}
     * @memberof SafeGrantDTO
     */
    funding: number;
    /**
     *
     * @type {number}
     * @memberof SafeGrantDTO
     */
    grantId: number;
    /**
     *
     * @type {string}
     * @memberof SafeGrantDTO
     */
    openingDate: string;
    /**
     *
     * @type {number}
     * @memberof SafeGrantDTO
     */
    sponsorId: number;
    /**
     *
     * @type {string}
     * @memberof SafeGrantDTO
     */
    title: string;
}
/**
 *
 * @export
 * @interface SafeReviewerDTO
 */
export interface SafeReviewerDTO {
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTO
     */
    address: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTO
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTO
     */
    email: string;
    /**
     *
     * @type {Array<number>}
     * @memberof SafeReviewerDTO
     */
    evals: Array<number>;
    /**
     *
     * @type {number}
     * @memberof SafeReviewerDTO
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof SafeReviewerDTO
     */
    institutionId: number;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTO
     */
    username: string;
}
/**
 *
 * @export
 * @interface SafeReviewerDTOReq
 */
export interface SafeReviewerDTOReq {
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTOReq
     */
    address: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTOReq
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTOReq
     */
    email: string;
    /**
     *
     * @type {Array<number>}
     * @memberof SafeReviewerDTOReq
     */
    evals: Array<number>;
    /**
     *
     * @type {number}
     * @memberof SafeReviewerDTOReq
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof SafeReviewerDTOReq
     */
    institutionId?: number;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTOReq
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTOReq
     */
    username: string;
}
/**
 *
 * @export
 * @interface SafeReviewerDTORes
 */
export interface SafeReviewerDTORes {
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTORes
     */
    address: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTORes
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTORes
     */
    email: string;
    /**
     *
     * @type {Array<number>}
     * @memberof SafeReviewerDTORes
     */
    evals: Array<number>;
    /**
     *
     * @type {number}
     * @memberof SafeReviewerDTORes
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof SafeReviewerDTORes
     */
    institutionId: number;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTORes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SafeReviewerDTORes
     */
    username: string;
}
/**
 *
 * @export
 * @interface SafeSponsorDTOReq
 */
export interface SafeSponsorDTOReq {
    /**
     *
     * @type {string}
     * @memberof SafeSponsorDTOReq
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof SafeSponsorDTOReq
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SafeSponsorDTOReq
     */
    phoneNumber: string;
    /**
     *
     * @type {number}
     * @memberof SafeSponsorDTOReq
     */
    sponsorID?: number;
    /**
     *
     * @type {string}
     * @memberof SafeSponsorDTOReq
     */
    username: string;
}
/**
 *
 * @export
 * @interface SafeSponsorDTORes
 */
export interface SafeSponsorDTORes {
    /**
     *
     * @type {string}
     * @memberof SafeSponsorDTORes
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof SafeSponsorDTORes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SafeSponsorDTORes
     */
    phoneNumber: string;
    /**
     *
     * @type {number}
     * @memberof SafeSponsorDTORes
     */
    sponsorID: number;
    /**
     *
     * @type {string}
     * @memberof SafeSponsorDTORes
     */
    username: string;
}
/**
 *
 * @export
 * @interface SafeStudentDTO
 */
export interface SafeStudentDTO {
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTO
     */
    address: string;
    /**
     *
     * @type {Array<number>}
     * @memberof SafeStudentDTO
     */
    applications: Array<number>;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTO
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTO
     */
    course: string;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTO
     */
    cvId: number;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTO
     */
    email: string;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTO
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTO
     */
    institutionId: number;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTO
     */
    username: string;
}
/**
 *
 * @export
 * @interface SafeStudentDTOReq
 */
export interface SafeStudentDTOReq {
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTOReq
     */
    address: string;
    /**
     *
     * @type {Array<number>}
     * @memberof SafeStudentDTOReq
     */
    applications: Array<number>;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTOReq
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTOReq
     */
    course: string;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTOReq
     */
    cvId?: number;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTOReq
     */
    email: string;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTOReq
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTOReq
     */
    institutionId?: number;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTOReq
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTOReq
     */
    username: string;
}
/**
 *
 * @export
 * @interface SafeStudentDTORes
 */
export interface SafeStudentDTORes {
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTORes
     */
    address: string;
    /**
     *
     * @type {Array<number>}
     * @memberof SafeStudentDTORes
     */
    applications: Array<number>;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTORes
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTORes
     */
    course: string;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTORes
     */
    cvId: number;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTORes
     */
    email: string;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTORes
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof SafeStudentDTORes
     */
    institutionId: number;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTORes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SafeStudentDTORes
     */
    username: string;
}
/**
 *
 * @export
 * @interface SponsorDTOReq
 */
export interface SponsorDTOReq {
    /**
     *
     * @type {string}
     * @memberof SponsorDTOReq
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof SponsorDTOReq
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SponsorDTOReq
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof SponsorDTOReq
     */
    phoneNumber: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SponsorDTOReq
     */
    roles: Array<string>;
    /**
     *
     * @type {number}
     * @memberof SponsorDTOReq
     */
    sponsorID?: number;
    /**
     *
     * @type {string}
     * @memberof SponsorDTOReq
     */
    username: string;
}
/**
 *
 * @export
 * @interface SponsorDTORes
 */
export interface SponsorDTORes {
    /**
     *
     * @type {string}
     * @memberof SponsorDTORes
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof SponsorDTORes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SponsorDTORes
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof SponsorDTORes
     */
    phoneNumber: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SponsorDTORes
     */
    roles: Array<string>;
    /**
     *
     * @type {number}
     * @memberof SponsorDTORes
     */
    sponsorID: number;
    /**
     *
     * @type {string}
     * @memberof SponsorDTORes
     */
    username: string;
}
/**
 *
 * @export
 * @interface StudentDTOReq
 */
export interface StudentDTOReq {
    /**
     *
     * @type {string}
     * @memberof StudentDTOReq
     */
    address: string;
    /**
     *
     * @type {Array<number>}
     * @memberof StudentDTOReq
     */
    applications: Array<number>;
    /**
     *
     * @type {string}
     * @memberof StudentDTOReq
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof StudentDTOReq
     */
    course: string;
    /**
     *
     * @type {number}
     * @memberof StudentDTOReq
     */
    cvId?: number;
    /**
     *
     * @type {string}
     * @memberof StudentDTOReq
     */
    email: string;
    /**
     *
     * @type {number}
     * @memberof StudentDTOReq
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof StudentDTOReq
     */
    institutionId?: number;
    /**
     *
     * @type {string}
     * @memberof StudentDTOReq
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof StudentDTOReq
     */
    password: string;
    /**
     *
     * @type {Array<string>}
     * @memberof StudentDTOReq
     */
    roles: Array<string>;
    /**
     *
     * @type {string}
     * @memberof StudentDTOReq
     */
    username: string;
}
/**
 *
 * @export
 * @interface StudentDTORes
 */
export interface StudentDTORes {
    /**
     *
     * @type {string}
     * @memberof StudentDTORes
     */
    address: string;
    /**
     *
     * @type {Array<number>}
     * @memberof StudentDTORes
     */
    applications: Array<number>;
    /**
     *
     * @type {string}
     * @memberof StudentDTORes
     */
    birthDate: string;
    /**
     *
     * @type {string}
     * @memberof StudentDTORes
     */
    course: string;
    /**
     *
     * @type {number}
     * @memberof StudentDTORes
     */
    cvId: number;
    /**
     *
     * @type {string}
     * @memberof StudentDTORes
     */
    email: string;
    /**
     *
     * @type {number}
     * @memberof StudentDTORes
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof StudentDTORes
     */
    institutionId: number;
    /**
     *
     * @type {string}
     * @memberof StudentDTORes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof StudentDTORes
     */
    password: string;
    /**
     *
     * @type {Array<string>}
     * @memberof StudentDTORes
     */
    roles: Array<string>;
    /**
     *
     * @type {string}
     * @memberof StudentDTORes
     */
    username: string;
}

/**
 * AdminControllerApi - axios parameter creator
 * @export
 */
export const AdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a role.
         * @param {RoleDTOReq} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleUsingPOST: async (role: RoleDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling createRoleUsingPOST.');
            }
            const localVarPath = `/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof role !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(role !== undefined ? role : {})
                : (role || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an Application.
         * @param {number} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleUsingDELETE: async (role: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling deleteRoleUsingDELETE.');
            }
            const localVarPath = `/admin/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns all roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRolesUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the info of a Role.
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleUsingGET: async (roleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling getRoleUsingGET.');
            }
            const localVarPath = `/admin/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the Roles for an User
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRolesUsingGET: async (userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling getUserRolesUsingGET.');
            }
            const localVarPath = `/admin/user/{userName}`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update role.
         * @param {RoleDTOReq} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleUsingPUT: async (role: RoleDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling updateRoleUsingPUT.');
            }
            const localVarPath = `/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof role !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(role !== undefined ? role : {})
                : (role || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminControllerApi - functional programming interface
 * @export
 */
export const AdminControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a role.
         * @param {RoleDTOReq} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleUsingPOST(role: RoleDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).createRoleUsingPOST(role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete an Application.
         * @param {number} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleUsingDELETE(role: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTORes>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).deleteRoleUsingDELETE(role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns all roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRolesUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTORes>>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getAllRolesUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the info of a Role.
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleUsingGET(roleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTORes>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getRoleUsingGET(roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the Roles for an User
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRolesUsingGET(userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTORes>>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getUserRolesUsingGET(userName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update role.
         * @param {RoleDTOReq} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleUsingPUT(role: RoleDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).updateRoleUsingPUT(role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminControllerApi - factory interface
 * @export
 */
export const AdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a role.
         * @param {RoleDTOReq} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleUsingPOST(role: RoleDTOReq, options?: any): AxiosPromise<void> {
            return AdminControllerApiFp(configuration).createRoleUsingPOST(role, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an Application.
         * @param {number} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleUsingDELETE(role: number, options?: any): AxiosPromise<RoleDTORes> {
            return AdminControllerApiFp(configuration).deleteRoleUsingDELETE(role, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRolesUsingGET(options?: any): AxiosPromise<Array<RoleDTORes>> {
            return AdminControllerApiFp(configuration).getAllRolesUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the info of a Role.
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleUsingGET(roleId: number, options?: any): AxiosPromise<RoleDTORes> {
            return AdminControllerApiFp(configuration).getRoleUsingGET(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the Roles for an User
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRolesUsingGET(userName: string, options?: any): AxiosPromise<Array<RoleDTORes>> {
            return AdminControllerApiFp(configuration).getUserRolesUsingGET(userName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update role.
         * @param {RoleDTOReq} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleUsingPUT(role: RoleDTOReq, options?: any): AxiosPromise<void> {
            return AdminControllerApiFp(configuration).updateRoleUsingPUT(role, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminControllerApi - object-oriented interface
 * @export
 * @class AdminControllerApi
 * @extends {BaseAPI}
 */
export class AdminControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a role.
     * @param {RoleDTOReq} role role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public createRoleUsingPOST(role: RoleDTOReq, options?: any) {
        return AdminControllerApiFp(this.configuration).createRoleUsingPOST(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete an Application.
     * @param {number} role role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public deleteRoleUsingDELETE(role: number, options?: any) {
        return AdminControllerApiFp(this.configuration).deleteRoleUsingDELETE(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Returns all roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getAllRolesUsingGET(options?: any) {
        return AdminControllerApiFp(this.configuration).getAllRolesUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Returns the info of a Role.
     * @param {number} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getRoleUsingGET(roleId: number, options?: any) {
        return AdminControllerApiFp(this.configuration).getRoleUsingGET(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Returns the Roles for an User
     * @param {string} userName userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getUserRolesUsingGET(userName: string, options?: any) {
        return AdminControllerApiFp(this.configuration).getUserRolesUsingGET(userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update role.
     * @param {RoleDTOReq} role role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateRoleUsingPUT(role: RoleDTOReq, options?: any) {
        return AdminControllerApiFp(this.configuration).updateRoleUsingPUT(role, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationControllerApi - axios parameter creator
 * @export
 */
export const ApplicationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Application for a Grant.
         * @param {ApplicationDTOReq} app app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUsingPOST: async (app: ApplicationDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            if (app === null || app === undefined) {
                throw new RequiredError('app','Required parameter app was null or undefined when calling createApplicationUsingPOST.');
            }
            const localVarPath = `/application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof app !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(app !== undefined ? app : {})
                : (app || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an Application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUsingDELETE: async (appId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteApplicationUsingDELETE.');
            }
            const localVarPath = `/application/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns all applications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllApplicationUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns all evaluations of a given Application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationEvaluationsUsingGET: async (appId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getApplicationEvaluationsUsingGET.');
            }
            const localVarPath = `/application/{appId}/evaluations`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the info of an application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsingGET: async (appId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getApplicationUsingGET.');
            }
            const localVarPath = `/application/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Application.
         * @param {ApplicationDTOReq} app app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUsingPUT: async (app: ApplicationDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            if (app === null || app === undefined) {
                throw new RequiredError('app','Required parameter app was null or undefined when calling updateApplicationUsingPUT.');
            }
            const localVarPath = `/application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof app !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(app !== undefined ? app : {})
                : (app || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationControllerApi - functional programming interface
 * @export
 */
export const ApplicationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Application for a Grant.
         * @param {ApplicationDTOReq} app app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationUsingPOST(app: ApplicationDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApplicationControllerApiAxiosParamCreator(configuration).createApplicationUsingPOST(app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete an Application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationUsingDELETE(appId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDTORes>> {
            const localVarAxiosArgs = await ApplicationControllerApiAxiosParamCreator(configuration).deleteApplicationUsingDELETE(appId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns all applications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllApplicationUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationDTORes>>> {
            const localVarAxiosArgs = await ApplicationControllerApiAxiosParamCreator(configuration).getAllApplicationUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns all evaluations of a given Application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationEvaluationsUsingGET(appId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvaluationDTORes>>> {
            const localVarAxiosArgs = await ApplicationControllerApiAxiosParamCreator(configuration).getApplicationEvaluationsUsingGET(appId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the info of an application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationUsingGET(appId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDTORes>> {
            const localVarAxiosArgs = await ApplicationControllerApiAxiosParamCreator(configuration).getApplicationUsingGET(appId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update Application.
         * @param {ApplicationDTOReq} app app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicationUsingPUT(app: ApplicationDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApplicationControllerApiAxiosParamCreator(configuration).updateApplicationUsingPUT(app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApplicationControllerApi - factory interface
 * @export
 */
export const ApplicationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a Application for a Grant.
         * @param {ApplicationDTOReq} app app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUsingPOST(app: ApplicationDTOReq, options?: any): AxiosPromise<void> {
            return ApplicationControllerApiFp(configuration).createApplicationUsingPOST(app, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an Application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUsingDELETE(appId: number, options?: any): AxiosPromise<ApplicationDTORes> {
            return ApplicationControllerApiFp(configuration).deleteApplicationUsingDELETE(appId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all applications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllApplicationUsingGET(options?: any): AxiosPromise<Array<ApplicationDTORes>> {
            return ApplicationControllerApiFp(configuration).getAllApplicationUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all evaluations of a given Application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationEvaluationsUsingGET(appId: number, options?: any): AxiosPromise<Array<EvaluationDTORes>> {
            return ApplicationControllerApiFp(configuration).getApplicationEvaluationsUsingGET(appId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the info of an application.
         * @param {number} appId appId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsingGET(appId: number, options?: any): AxiosPromise<ApplicationDTORes> {
            return ApplicationControllerApiFp(configuration).getApplicationUsingGET(appId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Application.
         * @param {ApplicationDTOReq} app app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUsingPUT(app: ApplicationDTOReq, options?: any): AxiosPromise<void> {
            return ApplicationControllerApiFp(configuration).updateApplicationUsingPUT(app, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationControllerApi - object-oriented interface
 * @export
 * @class ApplicationControllerApi
 * @extends {BaseAPI}
 */
export class ApplicationControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a Application for a Grant.
     * @param {ApplicationDTOReq} app app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationControllerApi
     */
    public createApplicationUsingPOST(app: ApplicationDTOReq, options?: any) {
        return ApplicationControllerApiFp(this.configuration).createApplicationUsingPOST(app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete an Application.
     * @param {number} appId appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationControllerApi
     */
    public deleteApplicationUsingDELETE(appId: number, options?: any) {
        return ApplicationControllerApiFp(this.configuration).deleteApplicationUsingDELETE(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Returns all applications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationControllerApi
     */
    public getAllApplicationUsingGET(options?: any) {
        return ApplicationControllerApiFp(this.configuration).getAllApplicationUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Returns all evaluations of a given Application.
     * @param {number} appId appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationControllerApi
     */
    public getApplicationEvaluationsUsingGET(appId: number, options?: any) {
        return ApplicationControllerApiFp(this.configuration).getApplicationEvaluationsUsingGET(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Returns the info of an application.
     * @param {number} appId appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationControllerApi
     */
    public getApplicationUsingGET(appId: number, options?: any) {
        return ApplicationControllerApiFp(this.configuration).getApplicationUsingGET(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update Application.
     * @param {ApplicationDTOReq} app app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationControllerApi
     */
    public updateApplicationUsingPUT(app: ApplicationDTOReq, options?: any) {
        return ApplicationControllerApiFp(this.configuration).updateApplicationUsingPUT(app, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EvaluationControllerApi - axios parameter creator
 * @export
 */
export const EvaluationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a evaluation.
         * @param {EvaluationDTOReq} evaluation evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluationUsingPOST: async (evaluation: EvaluationDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'evaluation' is not null or undefined
            if (evaluation === null || evaluation === undefined) {
                throw new RequiredError('evaluation','Required parameter evaluation was null or undefined when calling createEvaluationUsingPOST.');
            }
            const localVarPath = `/eval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof evaluation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(evaluation !== undefined ? evaluation : {})
                : (evaluation || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a evaluation.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluationUsingDELETE: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteEvaluationUsingDELETE.');
            }
            const localVarPath = `/eval/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all evaluations.
         * @param {number} [appId] appId
         * @param {number} [grantId] grantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvaluationsUsingGET: async (appId?: number, grantId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/eval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (grantId !== undefined) {
                localVarQueryParameter['grantId'] = grantId;
            }



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the requested evaluation.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getEvaluationUsingGET.');
            }
            const localVarPath = `/eval/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update evaluation information.
         * @param {EvaluationDTOReq} evaluation evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluationUsingPUT: async (evaluation: EvaluationDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'evaluation' is not null or undefined
            if (evaluation === null || evaluation === undefined) {
                throw new RequiredError('evaluation','Required parameter evaluation was null or undefined when calling updateEvaluationUsingPUT.');
            }
            const localVarPath = `/eval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof evaluation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(evaluation !== undefined ? evaluation : {})
                : (evaluation || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvaluationControllerApi - functional programming interface
 * @export
 */
export const EvaluationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a evaluation.
         * @param {EvaluationDTOReq} evaluation evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvaluationUsingPOST(evaluation: EvaluationDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EvaluationControllerApiAxiosParamCreator(configuration).createEvaluationUsingPOST(evaluation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a evaluation.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvaluationUsingDELETE(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationDTORes>> {
            const localVarAxiosArgs = await EvaluationControllerApiAxiosParamCreator(configuration).deleteEvaluationUsingDELETE(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all evaluations.
         * @param {number} [appId] appId
         * @param {number} [grantId] grantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEvaluationsUsingGET(appId?: number, grantId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvaluationDTORes>>> {
            const localVarAxiosArgs = await EvaluationControllerApiAxiosParamCreator(configuration).getAllEvaluationsUsingGET(appId, grantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return the requested evaluation.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluationUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationDTORes>> {
            const localVarAxiosArgs = await EvaluationControllerApiAxiosParamCreator(configuration).getEvaluationUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update evaluation information.
         * @param {EvaluationDTOReq} evaluation evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvaluationUsingPUT(evaluation: EvaluationDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EvaluationControllerApiAxiosParamCreator(configuration).updateEvaluationUsingPUT(evaluation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EvaluationControllerApi - factory interface
 * @export
 */
export const EvaluationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a evaluation.
         * @param {EvaluationDTOReq} evaluation evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluationUsingPOST(evaluation: EvaluationDTOReq, options?: any): AxiosPromise<void> {
            return EvaluationControllerApiFp(configuration).createEvaluationUsingPOST(evaluation, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a evaluation.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluationUsingDELETE(id: number, options?: any): AxiosPromise<EvaluationDTORes> {
            return EvaluationControllerApiFp(configuration).deleteEvaluationUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all evaluations.
         * @param {number} [appId] appId
         * @param {number} [grantId] grantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvaluationsUsingGET(appId?: number, grantId?: number, options?: any): AxiosPromise<Array<EvaluationDTORes>> {
            return EvaluationControllerApiFp(configuration).getAllEvaluationsUsingGET(appId, grantId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the requested evaluation.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationUsingGET(id: number, options?: any): AxiosPromise<EvaluationDTORes> {
            return EvaluationControllerApiFp(configuration).getEvaluationUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update evaluation information.
         * @param {EvaluationDTOReq} evaluation evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluationUsingPUT(evaluation: EvaluationDTOReq, options?: any): AxiosPromise<void> {
            return EvaluationControllerApiFp(configuration).updateEvaluationUsingPUT(evaluation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EvaluationControllerApi - object-oriented interface
 * @export
 * @class EvaluationControllerApi
 * @extends {BaseAPI}
 */
export class EvaluationControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a evaluation.
     * @param {EvaluationDTOReq} evaluation evaluation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationControllerApi
     */
    public createEvaluationUsingPOST(evaluation: EvaluationDTOReq, options?: any) {
        return EvaluationControllerApiFp(this.configuration).createEvaluationUsingPOST(evaluation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a evaluation.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationControllerApi
     */
    public deleteEvaluationUsingDELETE(id: number, options?: any) {
        return EvaluationControllerApiFp(this.configuration).deleteEvaluationUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all evaluations.
     * @param {number} [appId] appId
     * @param {number} [grantId] grantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationControllerApi
     */
    public getAllEvaluationsUsingGET(appId?: number, grantId?: number, options?: any) {
        return EvaluationControllerApiFp(this.configuration).getAllEvaluationsUsingGET(appId, grantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return the requested evaluation.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationControllerApi
     */
    public getEvaluationUsingGET(id: number, options?: any) {
        return EvaluationControllerApiFp(this.configuration).getEvaluationUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update evaluation information.
     * @param {EvaluationDTOReq} evaluation evaluation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationControllerApi
     */
    public updateEvaluationUsingPUT(evaluation: EvaluationDTOReq, options?: any) {
        return EvaluationControllerApiFp(this.configuration).updateEvaluationUsingPUT(evaluation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GrantControllerApi - axios parameter creator
 * @export
 */
export const GrantControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a grant.
         * @param {GrantDTOReq} grant grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrantUsingPOST: async (grant: GrantDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'grant' is not null or undefined
            if (grant === null || grant === undefined) {
                throw new RequiredError('grant','Required parameter grant was null or undefined when calling createGrantUsingPOST.');
            }
            const localVarPath = `/grant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof grant !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(grant !== undefined ? grant : {})
                : (grant || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrantUsingDELETE: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGrantUsingDELETE.');
            }
            const localVarPath = `/grant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all applications for a Grant.
         * @param {number} id id
         * @param {'DRAFT' | 'GRANTED' | 'NOT_GRANTED' | 'SUBMITTED'} [status] status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantApplicationsUsingGET: async (id: number, status?: 'DRAFT' | 'GRANTED' | 'NOT_GRANTED' | 'SUBMITTED', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGrantApplicationsUsingGET.');
            }
            const localVarPath = `/grant/{id}/application`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns all evaluations of a given grant.
         * @param {number} grantId grantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantEvaluationsUsingGET: async (grantId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantId' is not null or undefined
            if (grantId === null || grantId === undefined) {
                throw new RequiredError('grantId','Required parameter grantId was null or undefined when calling getGrantEvaluationsUsingGET.');
            }
            const localVarPath = `/grant/{appId}/evaluations`
                .replace(`{${"grantId"}}`, encodeURIComponent(String(grantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return a Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGrantUsingGET.');
            }
            const localVarPath = `/grant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all Grants
         * @param {string} [name] name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantsUsingGET: async (name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/grant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the Panel info for the Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPanelUsingGET.');
            }
            const localVarPath = `/grant/{id}/panel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Grant.
         * @param {GrantDTOReq} grant grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGrantUsingPUT: async (grant: GrantDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'grant' is not null or undefined
            if (grant === null || grant === undefined) {
                throw new RequiredError('grant','Required parameter grant was null or undefined when calling updateGrantUsingPUT.');
            }
            const localVarPath = `/grant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof grant !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(grant !== undefined ? grant : {})
                : (grant || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GrantControllerApi - functional programming interface
 * @export
 */
export const GrantControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a grant.
         * @param {GrantDTOReq} grant grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGrantUsingPOST(grant: GrantDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GrantControllerApiAxiosParamCreator(configuration).createGrantUsingPOST(grant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGrantUsingDELETE(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrantDTORes>> {
            const localVarAxiosArgs = await GrantControllerApiAxiosParamCreator(configuration).deleteGrantUsingDELETE(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all applications for a Grant.
         * @param {number} id id
         * @param {'DRAFT' | 'GRANTED' | 'NOT_GRANTED' | 'SUBMITTED'} [status] status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantApplicationsUsingGET(id: number, status?: 'DRAFT' | 'GRANTED' | 'NOT_GRANTED' | 'SUBMITTED', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationSafeDTO>>> {
            const localVarAxiosArgs = await GrantControllerApiAxiosParamCreator(configuration).getGrantApplicationsUsingGET(id, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns all evaluations of a given grant.
         * @param {number} grantId grantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantEvaluationsUsingGET(grantId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvaluationDTO>>> {
            const localVarAxiosArgs = await GrantControllerApiAxiosParamCreator(configuration).getGrantEvaluationsUsingGET(grantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return a Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrantDTORes>> {
            const localVarAxiosArgs = await GrantControllerApiAxiosParamCreator(configuration).getGrantUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all Grants
         * @param {string} [name] name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantsUsingGET(name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GrantDTORes>>> {
            const localVarAxiosArgs = await GrantControllerApiAxiosParamCreator(configuration).getGrantsUsingGET(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the Panel info for the Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPanelUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PanelDTO>> {
            const localVarAxiosArgs = await GrantControllerApiAxiosParamCreator(configuration).getPanelUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update Grant.
         * @param {GrantDTOReq} grant grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGrantUsingPUT(grant: GrantDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GrantControllerApiAxiosParamCreator(configuration).updateGrantUsingPUT(grant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GrantControllerApi - factory interface
 * @export
 */
export const GrantControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a grant.
         * @param {GrantDTOReq} grant grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrantUsingPOST(grant: GrantDTOReq, options?: any): AxiosPromise<void> {
            return GrantControllerApiFp(configuration).createGrantUsingPOST(grant, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrantUsingDELETE(id: number, options?: any): AxiosPromise<GrantDTORes> {
            return GrantControllerApiFp(configuration).deleteGrantUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all applications for a Grant.
         * @param {number} id id
         * @param {'DRAFT' | 'GRANTED' | 'NOT_GRANTED' | 'SUBMITTED'} [status] status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantApplicationsUsingGET(id: number, status?: 'DRAFT' | 'GRANTED' | 'NOT_GRANTED' | 'SUBMITTED', options?: any): AxiosPromise<Array<ApplicationSafeDTO>> {
            return GrantControllerApiFp(configuration).getGrantApplicationsUsingGET(id, status, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all evaluations of a given grant.
         * @param {number} grantId grantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantEvaluationsUsingGET(grantId: number, options?: any): AxiosPromise<Array<EvaluationDTO>> {
            return GrantControllerApiFp(configuration).getGrantEvaluationsUsingGET(grantId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return a Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantUsingGET(id: number, options?: any): AxiosPromise<GrantDTORes> {
            return GrantControllerApiFp(configuration).getGrantUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all Grants
         * @param {string} [name] name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantsUsingGET(name?: string, options?: any): AxiosPromise<Array<GrantDTORes>> {
            return GrantControllerApiFp(configuration).getGrantsUsingGET(name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the Panel info for the Grant.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelUsingGET(id: number, options?: any): AxiosPromise<PanelDTO> {
            return GrantControllerApiFp(configuration).getPanelUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Grant.
         * @param {GrantDTOReq} grant grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGrantUsingPUT(grant: GrantDTOReq, options?: any): AxiosPromise<void> {
            return GrantControllerApiFp(configuration).updateGrantUsingPUT(grant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GrantControllerApi - object-oriented interface
 * @export
 * @class GrantControllerApi
 * @extends {BaseAPI}
 */
export class GrantControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a grant.
     * @param {GrantDTOReq} grant grant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantControllerApi
     */
    public createGrantUsingPOST(grant: GrantDTOReq, options?: any) {
        return GrantControllerApiFp(this.configuration).createGrantUsingPOST(grant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a Grant.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantControllerApi
     */
    public deleteGrantUsingDELETE(id: number, options?: any) {
        return GrantControllerApiFp(this.configuration).deleteGrantUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all applications for a Grant.
     * @param {number} id id
     * @param {'DRAFT' | 'GRANTED' | 'NOT_GRANTED' | 'SUBMITTED'} [status] status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantControllerApi
     */
    public getGrantApplicationsUsingGET(id: number, status?: 'DRAFT' | 'GRANTED' | 'NOT_GRANTED' | 'SUBMITTED', options?: any) {
        return GrantControllerApiFp(this.configuration).getGrantApplicationsUsingGET(id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Returns all evaluations of a given grant.
     * @param {number} grantId grantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantControllerApi
     */
    public getGrantEvaluationsUsingGET(grantId: number, options?: any) {
        return GrantControllerApiFp(this.configuration).getGrantEvaluationsUsingGET(grantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return a Grant.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantControllerApi
     */
    public getGrantUsingGET(id: number, options?: any) {
        return GrantControllerApiFp(this.configuration).getGrantUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all Grants
     * @param {string} [name] name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantControllerApi
     */
    public getGrantsUsingGET(name?: string, options?: any) {
        return GrantControllerApiFp(this.configuration).getGrantsUsingGET(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Returns the Panel info for the Grant.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantControllerApi
     */
    public getPanelUsingGET(id: number, options?: any) {
        return GrantControllerApiFp(this.configuration).getPanelUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update Grant.
     * @param {GrantDTOReq} grant grant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantControllerApi
     */
    public updateGrantUsingPUT(grant: GrantDTOReq, options?: any) {
        return GrantControllerApiFp(this.configuration).updateGrantUsingPUT(grant, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InstitutionControllerApi - axios parameter creator
 * @export
 */
export const InstitutionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete an institution from the platform
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstitutionUsingDELETE: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteInstitutionUsingDELETE.');
            }
            const localVarPath = `/institution/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all reviewers of a given institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionReviewersUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstitutionReviewersUsingGET.');
            }
            const localVarPath = `/institution/{id}/reviewers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all students of a given institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionStudentsUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstitutionStudentsUsingGET.');
            }
            const localVarPath = `/institution/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return a requested institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstitutionUsingGET.');
            }
            const localVarPath = `/institution/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all institutions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionsUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/institution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Register an institution in the platform.
         * @param {InstitutionDTOReq} institution institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerInstitutionUsingPOST: async (institution: InstitutionDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'institution' is not null or undefined
            if (institution === null || institution === undefined) {
                throw new RequiredError('institution','Required parameter institution was null or undefined when calling registerInstitutionUsingPOST.');
            }
            const localVarPath = `/institution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof institution !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(institution !== undefined ? institution : {})
                : (institution || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update the information of a given institution
         * @param {string} [email]
         * @param {number} [id]
         * @param {string} [name]
         * @param {string} [phoneNumb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstitutionUsingPUT: async (email?: string, id?: number, name?: string, phoneNumb?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/institution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (phoneNumb !== undefined) {
                localVarQueryParameter['phoneNumb'] = phoneNumb;
            }



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstitutionControllerApi - functional programming interface
 * @export
 */
export const InstitutionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete an institution from the platform
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInstitutionUsingDELETE(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstitutionDTORes>> {
            const localVarAxiosArgs = await InstitutionControllerApiAxiosParamCreator(configuration).deleteInstitutionUsingDELETE(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all reviewers of a given institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstitutionReviewersUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeReviewerDTO>>> {
            const localVarAxiosArgs = await InstitutionControllerApiAxiosParamCreator(configuration).getInstitutionReviewersUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all students of a given institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstitutionStudentsUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeStudentDTO>>> {
            const localVarAxiosArgs = await InstitutionControllerApiAxiosParamCreator(configuration).getInstitutionStudentsUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return a requested institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstitutionUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstitutionDTORes>> {
            const localVarAxiosArgs = await InstitutionControllerApiAxiosParamCreator(configuration).getInstitutionUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all institutions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstitutionsUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstitutionDTORes>>> {
            const localVarAxiosArgs = await InstitutionControllerApiAxiosParamCreator(configuration).getInstitutionsUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Register an institution in the platform.
         * @param {InstitutionDTOReq} institution institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerInstitutionUsingPOST(institution: InstitutionDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InstitutionControllerApiAxiosParamCreator(configuration).registerInstitutionUsingPOST(institution, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update the information of a given institution
         * @param {string} [email]
         * @param {number} [id]
         * @param {string} [name]
         * @param {string} [phoneNumb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInstitutionUsingPUT(email?: string, id?: number, name?: string, phoneNumb?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InstitutionControllerApiAxiosParamCreator(configuration).updateInstitutionUsingPUT(email, id, name, phoneNumb, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InstitutionControllerApi - factory interface
 * @export
 */
export const InstitutionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Delete an institution from the platform
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstitutionUsingDELETE(id: number, options?: any): AxiosPromise<InstitutionDTORes> {
            return InstitutionControllerApiFp(configuration).deleteInstitutionUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all reviewers of a given institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionReviewersUsingGET(id: number, options?: any): AxiosPromise<Array<SafeReviewerDTO>> {
            return InstitutionControllerApiFp(configuration).getInstitutionReviewersUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all students of a given institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionStudentsUsingGET(id: number, options?: any): AxiosPromise<Array<SafeStudentDTO>> {
            return InstitutionControllerApiFp(configuration).getInstitutionStudentsUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return a requested institution.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionUsingGET(id: number, options?: any): AxiosPromise<InstitutionDTORes> {
            return InstitutionControllerApiFp(configuration).getInstitutionUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all institutions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionsUsingGET(options?: any): AxiosPromise<Array<InstitutionDTORes>> {
            return InstitutionControllerApiFp(configuration).getInstitutionsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Register an institution in the platform.
         * @param {InstitutionDTOReq} institution institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerInstitutionUsingPOST(institution: InstitutionDTOReq, options?: any): AxiosPromise<void> {
            return InstitutionControllerApiFp(configuration).registerInstitutionUsingPOST(institution, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the information of a given institution
         * @param {string} [email]
         * @param {number} [id]
         * @param {string} [name]
         * @param {string} [phoneNumb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstitutionUsingPUT(email?: string, id?: number, name?: string, phoneNumb?: string, options?: any): AxiosPromise<void> {
            return InstitutionControllerApiFp(configuration).updateInstitutionUsingPUT(email, id, name, phoneNumb, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstitutionControllerApi - object-oriented interface
 * @export
 * @class InstitutionControllerApi
 * @extends {BaseAPI}
 */
export class InstitutionControllerApi extends BaseAPI {
    /**
     *
     * @summary Delete an institution from the platform
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionControllerApi
     */
    public deleteInstitutionUsingDELETE(id: number, options?: any) {
        return InstitutionControllerApiFp(this.configuration).deleteInstitutionUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all reviewers of a given institution.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionControllerApi
     */
    public getInstitutionReviewersUsingGET(id: number, options?: any) {
        return InstitutionControllerApiFp(this.configuration).getInstitutionReviewersUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all students of a given institution.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionControllerApi
     */
    public getInstitutionStudentsUsingGET(id: number, options?: any) {
        return InstitutionControllerApiFp(this.configuration).getInstitutionStudentsUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return a requested institution.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionControllerApi
     */
    public getInstitutionUsingGET(id: number, options?: any) {
        return InstitutionControllerApiFp(this.configuration).getInstitutionUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all institutions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionControllerApi
     */
    public getInstitutionsUsingGET(options?: any) {
        return InstitutionControllerApiFp(this.configuration).getInstitutionsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Register an institution in the platform.
     * @param {InstitutionDTOReq} institution institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionControllerApi
     */
    public registerInstitutionUsingPOST(institution: InstitutionDTOReq, options?: any) {
        return InstitutionControllerApiFp(this.configuration).registerInstitutionUsingPOST(institution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update the information of a given institution
     * @param {string} [email]
     * @param {number} [id]
     * @param {string} [name]
     * @param {string} [phoneNumb]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionControllerApi
     */
    public updateInstitutionUsingPUT(email?: string, id?: number, name?: string, phoneNumb?: string, options?: any) {
        return InstitutionControllerApiFp(this.configuration).updateInstitutionUsingPUT(email, id, name, phoneNumb, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PanelControllerApi - axios parameter creator
 * @export
 */
export const PanelControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Panel.
         * @param {PanelDTOReq} panel panel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPanelUsingPOST: async (panel: PanelDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'panel' is not null or undefined
            if (panel === null || panel === undefined) {
                throw new RequiredError('panel','Required parameter panel was null or undefined when calling createPanelUsingPOST.');
            }
            const localVarPath = `/panel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof panel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(panel !== undefined ? panel : {})
                : (panel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Panel.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePanelUsingDELETE: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePanelUsingDELETE.');
            }
            const localVarPath = `/panel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return a Panel.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelUsingGET1: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPanelUsingGET1.');
            }
            const localVarPath = `/panel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all Panels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelsUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/panel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Panel info
         * @param {number} id id
         * @param {PanelDTOReq} panel panel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePanelUsingPUT: async (id: number, panel: PanelDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePanelUsingPUT.');
            }
            // verify required parameter 'panel' is not null or undefined
            if (panel === null || panel === undefined) {
                throw new RequiredError('panel','Required parameter panel was null or undefined when calling updatePanelUsingPUT.');
            }
            const localVarPath = `/panel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof panel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(panel !== undefined ? panel : {})
                : (panel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PanelControllerApi - functional programming interface
 * @export
 */
export const PanelControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Panel.
         * @param {PanelDTOReq} panel panel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPanelUsingPOST(panel: PanelDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PanelControllerApiAxiosParamCreator(configuration).createPanelUsingPOST(panel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a Panel.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePanelUsingDELETE(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PanelDTORes>> {
            const localVarAxiosArgs = await PanelControllerApiAxiosParamCreator(configuration).deletePanelUsingDELETE(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return a Panel.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPanelUsingGET1(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PanelDTORes>> {
            const localVarAxiosArgs = await PanelControllerApiAxiosParamCreator(configuration).getPanelUsingGET1(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all Panels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPanelsUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PanelDTORes>>> {
            const localVarAxiosArgs = await PanelControllerApiAxiosParamCreator(configuration).getPanelsUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update Panel info
         * @param {number} id id
         * @param {PanelDTOReq} panel panel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePanelUsingPUT(id: number, panel: PanelDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PanelControllerApiAxiosParamCreator(configuration).updatePanelUsingPUT(id, panel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PanelControllerApi - factory interface
 * @export
 */
export const PanelControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a Panel.
         * @param {PanelDTOReq} panel panel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPanelUsingPOST(panel: PanelDTOReq, options?: any): AxiosPromise<void> {
            return PanelControllerApiFp(configuration).createPanelUsingPOST(panel, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Panel.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePanelUsingDELETE(id: number, options?: any): AxiosPromise<PanelDTORes> {
            return PanelControllerApiFp(configuration).deletePanelUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return a Panel.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelUsingGET1(id: number, options?: any): AxiosPromise<PanelDTORes> {
            return PanelControllerApiFp(configuration).getPanelUsingGET1(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all Panels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelsUsingGET(options?: any): AxiosPromise<Array<PanelDTORes>> {
            return PanelControllerApiFp(configuration).getPanelsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Panel info
         * @param {number} id id
         * @param {PanelDTOReq} panel panel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePanelUsingPUT(id: number, panel: PanelDTOReq, options?: any): AxiosPromise<void> {
            return PanelControllerApiFp(configuration).updatePanelUsingPUT(id, panel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PanelControllerApi - object-oriented interface
 * @export
 * @class PanelControllerApi
 * @extends {BaseAPI}
 */
export class PanelControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a Panel.
     * @param {PanelDTOReq} panel panel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PanelControllerApi
     */
    public createPanelUsingPOST(panel: PanelDTOReq, options?: any) {
        return PanelControllerApiFp(this.configuration).createPanelUsingPOST(panel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a Panel.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PanelControllerApi
     */
    public deletePanelUsingDELETE(id: number, options?: any) {
        return PanelControllerApiFp(this.configuration).deletePanelUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return a Panel.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PanelControllerApi
     */
    public getPanelUsingGET1(id: number, options?: any) {
        return PanelControllerApiFp(this.configuration).getPanelUsingGET1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all Panels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PanelControllerApi
     */
    public getPanelsUsingGET(options?: any) {
        return PanelControllerApiFp(this.configuration).getPanelsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update Panel info
     * @param {number} id id
     * @param {PanelDTOReq} panel panel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PanelControllerApi
     */
    public updatePanelUsingPUT(id: number, panel: PanelDTOReq, options?: any) {
        return PanelControllerApiFp(this.configuration).updatePanelUsingPUT(id, panel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReviewerControllerApi - axios parameter creator
 * @export
 */
export const ReviewerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Reviewer.
         * @param {ReviewerDTOReq} reviewer reviewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReviewerUsingPOST: async (reviewer: ReviewerDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewer' is not null or undefined
            if (reviewer === null || reviewer === undefined) {
                throw new RequiredError('reviewer','Required parameter reviewer was null or undefined when calling createReviewerUsingPOST.');
            }
            const localVarPath = `/reviewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof reviewer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(reviewer !== undefined ? reviewer : {})
                : (reviewer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Reviewer.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewerUsingDELETE: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteReviewerUsingDELETE.');
            }
            const localVarPath = `/reviewer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all evaluations of a Reviewer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewerEvaluationsUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getReviewerEvaluationsUsingGET.');
            }
            const localVarPath = `/reviewer/{id}/evaluation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all panels of a Reviewer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewerPanelsUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getReviewerPanelsUsingGET.');
            }
            const localVarPath = `/reviewer/{id}/panels`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return a Reviewer.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewerUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getReviewerUsingGET.');
            }
            const localVarPath = `/reviewer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all Reviewers.
         * @param {string} [email] email
         * @param {string} [name] name
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewersUsingGET: async (email?: string, name?: string, username?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reviewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Reviewer info.
         * @param {SafeReviewerDTOReq} reviewer reviewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewerUsingPUT: async (reviewer: SafeReviewerDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewer' is not null or undefined
            if (reviewer === null || reviewer === undefined) {
                throw new RequiredError('reviewer','Required parameter reviewer was null or undefined when calling updateReviewerUsingPUT.');
            }
            const localVarPath = `/reviewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof reviewer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(reviewer !== undefined ? reviewer : {})
                : (reviewer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewerControllerApi - functional programming interface
 * @export
 */
export const ReviewerControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Reviewer.
         * @param {ReviewerDTOReq} reviewer reviewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReviewerUsingPOST(reviewer: ReviewerDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ReviewerControllerApiAxiosParamCreator(configuration).createReviewerUsingPOST(reviewer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a Reviewer.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReviewerUsingDELETE(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewerDTORes>> {
            const localVarAxiosArgs = await ReviewerControllerApiAxiosParamCreator(configuration).deleteReviewerUsingDELETE(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all evaluations of a Reviewer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewerEvaluationsUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvaluationDTO>>> {
            const localVarAxiosArgs = await ReviewerControllerApiAxiosParamCreator(configuration).getReviewerEvaluationsUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all panels of a Reviewer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewerPanelsUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PanelDTO>>> {
            const localVarAxiosArgs = await ReviewerControllerApiAxiosParamCreator(configuration).getReviewerPanelsUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return a Reviewer.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewerUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewerDTORes>> {
            const localVarAxiosArgs = await ReviewerControllerApiAxiosParamCreator(configuration).getReviewerUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all Reviewers.
         * @param {string} [email] email
         * @param {string} [name] name
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewersUsingGET(email?: string, name?: string, username?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeReviewerDTORes>>> {
            const localVarAxiosArgs = await ReviewerControllerApiAxiosParamCreator(configuration).getReviewersUsingGET(email, name, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update Reviewer info.
         * @param {SafeReviewerDTOReq} reviewer reviewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReviewerUsingPUT(reviewer: SafeReviewerDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ReviewerControllerApiAxiosParamCreator(configuration).updateReviewerUsingPUT(reviewer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReviewerControllerApi - factory interface
 * @export
 */
export const ReviewerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a Reviewer.
         * @param {ReviewerDTOReq} reviewer reviewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReviewerUsingPOST(reviewer: ReviewerDTOReq, options?: any): AxiosPromise<void> {
            return ReviewerControllerApiFp(configuration).createReviewerUsingPOST(reviewer, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Reviewer.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewerUsingDELETE(id: number, options?: any): AxiosPromise<ReviewerDTORes> {
            return ReviewerControllerApiFp(configuration).deleteReviewerUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all evaluations of a Reviewer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewerEvaluationsUsingGET(id: number, options?: any): AxiosPromise<Array<EvaluationDTO>> {
            return ReviewerControllerApiFp(configuration).getReviewerEvaluationsUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all panels of a Reviewer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewerPanelsUsingGET(id: number, options?: any): AxiosPromise<Array<PanelDTO>> {
            return ReviewerControllerApiFp(configuration).getReviewerPanelsUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return a Reviewer.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewerUsingGET(id: number, options?: any): AxiosPromise<ReviewerDTORes> {
            return ReviewerControllerApiFp(configuration).getReviewerUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all Reviewers.
         * @param {string} [email] email
         * @param {string} [name] name
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewersUsingGET(email?: string, name?: string, username?: string, options?: any): AxiosPromise<Array<SafeReviewerDTORes>> {
            return ReviewerControllerApiFp(configuration).getReviewersUsingGET(email, name, username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Reviewer info.
         * @param {SafeReviewerDTOReq} reviewer reviewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewerUsingPUT(reviewer: SafeReviewerDTOReq, options?: any): AxiosPromise<void> {
            return ReviewerControllerApiFp(configuration).updateReviewerUsingPUT(reviewer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewerControllerApi - object-oriented interface
 * @export
 * @class ReviewerControllerApi
 * @extends {BaseAPI}
 */
export class ReviewerControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a Reviewer.
     * @param {ReviewerDTOReq} reviewer reviewer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewerControllerApi
     */
    public createReviewerUsingPOST(reviewer: ReviewerDTOReq, options?: any) {
        return ReviewerControllerApiFp(this.configuration).createReviewerUsingPOST(reviewer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a Reviewer.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewerControllerApi
     */
    public deleteReviewerUsingDELETE(id: number, options?: any) {
        return ReviewerControllerApiFp(this.configuration).deleteReviewerUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all evaluations of a Reviewer
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewerControllerApi
     */
    public getReviewerEvaluationsUsingGET(id: number, options?: any) {
        return ReviewerControllerApiFp(this.configuration).getReviewerEvaluationsUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all panels of a Reviewer
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewerControllerApi
     */
    public getReviewerPanelsUsingGET(id: number, options?: any) {
        return ReviewerControllerApiFp(this.configuration).getReviewerPanelsUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return a Reviewer.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewerControllerApi
     */
    public getReviewerUsingGET(id: number, options?: any) {
        return ReviewerControllerApiFp(this.configuration).getReviewerUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all Reviewers.
     * @param {string} [email] email
     * @param {string} [name] name
     * @param {string} [username] username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewerControllerApi
     */
    public getReviewersUsingGET(email?: string, name?: string, username?: string, options?: any) {
        return ReviewerControllerApiFp(this.configuration).getReviewersUsingGET(email, name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update Reviewer info.
     * @param {SafeReviewerDTOReq} reviewer reviewer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewerControllerApi
     */
    public updateReviewerUsingPUT(reviewer: SafeReviewerDTOReq, options?: any) {
        return ReviewerControllerApiFp(this.configuration).updateReviewerUsingPUT(reviewer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SponsorControllerApi - axios parameter creator
 * @export
 */
export const SponsorControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Sponsor.
         * @param {SponsorDTOReq} sponsor sponsor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSponsorUsingPOST: async (sponsor: SponsorDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sponsor' is not null or undefined
            if (sponsor === null || sponsor === undefined) {
                throw new RequiredError('sponsor','Required parameter sponsor was null or undefined when calling createSponsorUsingPOST.');
            }
            const localVarPath = `/sponsor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof sponsor !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(sponsor !== undefined ? sponsor : {})
                : (sponsor || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSponsorUsingDELETE: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSponsorUsingDELETE.');
            }
            const localVarPath = `/sponsor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all Grants of a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantSponsorUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGrantSponsorUsingGET.');
            }
            const localVarPath = `/sponsor/{id}/grant`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSponsorUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSponsorUsingGET.');
            }
            const localVarPath = `/sponsor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all Sponsors.
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSponsorsUsingGET: async (username?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sponsor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a Sponsor.
         * @param {SafeSponsorDTOReq} sponsor sponsor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSponsorUsingPUT: async (sponsor: SafeSponsorDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sponsor' is not null or undefined
            if (sponsor === null || sponsor === undefined) {
                throw new RequiredError('sponsor','Required parameter sponsor was null or undefined when calling updateSponsorUsingPUT.');
            }
            const localVarPath = `/sponsor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof sponsor !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(sponsor !== undefined ? sponsor : {})
                : (sponsor || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SponsorControllerApi - functional programming interface
 * @export
 */
export const SponsorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Sponsor.
         * @param {SponsorDTOReq} sponsor sponsor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSponsorUsingPOST(sponsor: SponsorDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SponsorControllerApiAxiosParamCreator(configuration).createSponsorUsingPOST(sponsor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSponsorUsingDELETE(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SponsorDTORes>> {
            const localVarAxiosArgs = await SponsorControllerApiAxiosParamCreator(configuration).deleteSponsorUsingDELETE(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all Grants of a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantSponsorUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeGrantDTO>>> {
            const localVarAxiosArgs = await SponsorControllerApiAxiosParamCreator(configuration).getGrantSponsorUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSponsorUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SponsorDTORes>> {
            const localVarAxiosArgs = await SponsorControllerApiAxiosParamCreator(configuration).getSponsorUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all Sponsors.
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSponsorsUsingGET(username?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeSponsorDTORes>>> {
            const localVarAxiosArgs = await SponsorControllerApiAxiosParamCreator(configuration).getSponsorsUsingGET(username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a Sponsor.
         * @param {SafeSponsorDTOReq} sponsor sponsor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSponsorUsingPUT(sponsor: SafeSponsorDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SponsorControllerApiAxiosParamCreator(configuration).updateSponsorUsingPUT(sponsor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SponsorControllerApi - factory interface
 * @export
 */
export const SponsorControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a Sponsor.
         * @param {SponsorDTOReq} sponsor sponsor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSponsorUsingPOST(sponsor: SponsorDTOReq, options?: any): AxiosPromise<void> {
            return SponsorControllerApiFp(configuration).createSponsorUsingPOST(sponsor, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSponsorUsingDELETE(id: number, options?: any): AxiosPromise<SponsorDTORes> {
            return SponsorControllerApiFp(configuration).deleteSponsorUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all Grants of a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantSponsorUsingGET(id: number, options?: any): AxiosPromise<Array<SafeGrantDTO>> {
            return SponsorControllerApiFp(configuration).getGrantSponsorUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return a Sponsor.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSponsorUsingGET(id: number, options?: any): AxiosPromise<SponsorDTORes> {
            return SponsorControllerApiFp(configuration).getSponsorUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all Sponsors.
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSponsorsUsingGET(username?: string, options?: any): AxiosPromise<Array<SafeSponsorDTORes>> {
            return SponsorControllerApiFp(configuration).getSponsorsUsingGET(username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a Sponsor.
         * @param {SafeSponsorDTOReq} sponsor sponsor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSponsorUsingPUT(sponsor: SafeSponsorDTOReq, options?: any): AxiosPromise<void> {
            return SponsorControllerApiFp(configuration).updateSponsorUsingPUT(sponsor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SponsorControllerApi - object-oriented interface
 * @export
 * @class SponsorControllerApi
 * @extends {BaseAPI}
 */
export class SponsorControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a Sponsor.
     * @param {SponsorDTOReq} sponsor sponsor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SponsorControllerApi
     */
    public createSponsorUsingPOST(sponsor: SponsorDTOReq, options?: any) {
        return SponsorControllerApiFp(this.configuration).createSponsorUsingPOST(sponsor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a Sponsor.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SponsorControllerApi
     */
    public deleteSponsorUsingDELETE(id: number, options?: any) {
        return SponsorControllerApiFp(this.configuration).deleteSponsorUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all Grants of a Sponsor.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SponsorControllerApi
     */
    public getGrantSponsorUsingGET(id: number, options?: any) {
        return SponsorControllerApiFp(this.configuration).getGrantSponsorUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return a Sponsor.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SponsorControllerApi
     */
    public getSponsorUsingGET(id: number, options?: any) {
        return SponsorControllerApiFp(this.configuration).getSponsorUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all Sponsors.
     * @param {string} [username] username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SponsorControllerApi
     */
    public getSponsorsUsingGET(username?: string, options?: any) {
        return SponsorControllerApiFp(this.configuration).getSponsorsUsingGET(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a Sponsor.
     * @param {SafeSponsorDTOReq} sponsor sponsor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SponsorControllerApi
     */
    public updateSponsorUsingPUT(sponsor: SafeSponsorDTOReq, options?: any) {
        return SponsorControllerApiFp(this.configuration).updateSponsorUsingPUT(sponsor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentControllerApi - axios parameter creator
 * @export
 */
export const StudentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Student\'s CV
         * @param {number} id id
         * @param {CVReq} cv cv
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCVUsingPOST: async (id: number, cv: CVReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createCVUsingPOST.');
            }
            // verify required parameter 'cv' is not null or undefined
            if (cv === null || cv === undefined) {
                throw new RequiredError('cv','Required parameter cv was null or undefined when calling createCVUsingPOST.');
            }
            const localVarPath = `/student/{id}/CV`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof cv !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(cv !== undefined ? cv : {})
                : (cv || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Student\'s CV
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCVUsingDELETE: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCVUsingDELETE.');
            }
            const localVarPath = `/student/{id}/CV`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a student.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudentUsingDELETE: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteStudentUsingDELETE.');
            }
            const localVarPath = `/student/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all enrolled students.
         * @param {string} [email] email
         * @param {string} [name] name
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStudentsUsingGET: async (email?: string, name?: string, username?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/student`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Student\'s CV
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCVUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCVUsingGET.');
            }
            const localVarPath = `/student/{id}/CV`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return a student\'s grant applications.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentApplicationsUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStudentApplicationsUsingGET.');
            }
            const localVarPath = `/student/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the requested student.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentUsingGET: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStudentUsingGET.');
            }
            const localVarPath = `/student/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Enroll a student in the platform.
         * @param {StudentDTOReq} student student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerStudentUsingPOST: async (student: StudentDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'student' is not null or undefined
            if (student === null || student === undefined) {
                throw new RequiredError('student','Required parameter student was null or undefined when calling registerStudentUsingPOST.');
            }
            const localVarPath = `/student`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof student !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(student !== undefined ? student : {})
                : (student || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Change a Student\'s CV
         * @param {number} id id
         * @param {CVReq} cv cv
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCVUsingPUT: async (id: number, cv: CVReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCVUsingPUT.');
            }
            // verify required parameter 'cv' is not null or undefined
            if (cv === null || cv === undefined) {
                throw new RequiredError('cv','Required parameter cv was null or undefined when calling updateCVUsingPUT.');
            }
            const localVarPath = `/student/{id}/CV`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof cv !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(cv !== undefined ? cv : {})
                : (cv || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update student information.
         * @param {SafeStudentDTOReq} student student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentUsingPUT: async (student: SafeStudentDTOReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'student' is not null or undefined
            if (student === null || student === undefined) {
                throw new RequiredError('student','Required parameter student was null or undefined when calling updateStudentUsingPUT.');
            }
            const localVarPath = `/student`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof student !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(student !== undefined ? student : {})
                : (student || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentControllerApi - functional programming interface
 * @export
 */
export const StudentControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Student\'s CV
         * @param {number} id id
         * @param {CVReq} cv cv
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCVUsingPOST(id: number, cv: CVReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).createCVUsingPOST(id, cv, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a Student\'s CV
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCVUsingDELETE(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CVRes>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).deleteCVUsingDELETE(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a student.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStudentUsingDELETE(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentDTORes>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).deleteStudentUsingDELETE(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return all enrolled students.
         * @param {string} [email] email
         * @param {string} [name] name
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStudentsUsingGET(email?: string, name?: string, username?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeStudentDTORes>>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).getAllStudentsUsingGET(email, name, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a Student\'s CV
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCVUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CVRes>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).getCVUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return a student\'s grant applications.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentApplicationsUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationDTO>>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).getStudentApplicationsUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Return the requested student.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentUsingGET(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SafeStudentDTORes>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).getStudentUsingGET(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Enroll a student in the platform.
         * @param {StudentDTOReq} student student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerStudentUsingPOST(student: StudentDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).registerStudentUsingPOST(student, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Change a Student\'s CV
         * @param {number} id id
         * @param {CVReq} cv cv
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCVUsingPUT(id: number, cv: CVReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).updateCVUsingPUT(id, cv, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update student information.
         * @param {SafeStudentDTOReq} student student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudentUsingPUT(student: SafeStudentDTOReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StudentControllerApiAxiosParamCreator(configuration).updateStudentUsingPUT(student, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StudentControllerApi - factory interface
 * @export
 */
export const StudentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a Student\'s CV
         * @param {number} id id
         * @param {CVReq} cv cv
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCVUsingPOST(id: number, cv: CVReq, options?: any): AxiosPromise<void> {
            return StudentControllerApiFp(configuration).createCVUsingPOST(id, cv, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Student\'s CV
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCVUsingDELETE(id: number, options?: any): AxiosPromise<CVRes> {
            return StudentControllerApiFp(configuration).deleteCVUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a student.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudentUsingDELETE(id: number, options?: any): AxiosPromise<StudentDTORes> {
            return StudentControllerApiFp(configuration).deleteStudentUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all enrolled students.
         * @param {string} [email] email
         * @param {string} [name] name
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStudentsUsingGET(email?: string, name?: string, username?: string, options?: any): AxiosPromise<Array<SafeStudentDTORes>> {
            return StudentControllerApiFp(configuration).getAllStudentsUsingGET(email, name, username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Student\'s CV
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCVUsingGET(id: number, options?: any): AxiosPromise<CVRes> {
            return StudentControllerApiFp(configuration).getCVUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return a student\'s grant applications.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentApplicationsUsingGET(id: number, options?: any): AxiosPromise<Array<ApplicationDTO>> {
            return StudentControllerApiFp(configuration).getStudentApplicationsUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the requested student.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentUsingGET(id: number, options?: any): AxiosPromise<SafeStudentDTORes> {
            return StudentControllerApiFp(configuration).getStudentUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Enroll a student in the platform.
         * @param {StudentDTOReq} student student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerStudentUsingPOST(student: StudentDTOReq, options?: any): AxiosPromise<void> {
            return StudentControllerApiFp(configuration).registerStudentUsingPOST(student, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change a Student\'s CV
         * @param {number} id id
         * @param {CVReq} cv cv
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCVUsingPUT(id: number, cv: CVReq, options?: any): AxiosPromise<void> {
            return StudentControllerApiFp(configuration).updateCVUsingPUT(id, cv, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update student information.
         * @param {SafeStudentDTOReq} student student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentUsingPUT(student: SafeStudentDTOReq, options?: any): AxiosPromise<void> {
            return StudentControllerApiFp(configuration).updateStudentUsingPUT(student, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentControllerApi - object-oriented interface
 * @export
 * @class StudentControllerApi
 * @extends {BaseAPI}
 */
export class StudentControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a Student\'s CV
     * @param {number} id id
     * @param {CVReq} cv cv
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public createCVUsingPOST(id: number, cv: CVReq, options?: any) {
        return StudentControllerApiFp(this.configuration).createCVUsingPOST(id, cv, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a Student\'s CV
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public deleteCVUsingDELETE(id: number, options?: any) {
        return StudentControllerApiFp(this.configuration).deleteCVUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a student.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public deleteStudentUsingDELETE(id: number, options?: any) {
        return StudentControllerApiFp(this.configuration).deleteStudentUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all enrolled students.
     * @param {string} [email] email
     * @param {string} [name] name
     * @param {string} [username] username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public getAllStudentsUsingGET(email?: string, name?: string, username?: string, options?: any) {
        return StudentControllerApiFp(this.configuration).getAllStudentsUsingGET(email, name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a Student\'s CV
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public getCVUsingGET(id: number, options?: any) {
        return StudentControllerApiFp(this.configuration).getCVUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return a student\'s grant applications.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public getStudentApplicationsUsingGET(id: number, options?: any) {
        return StudentControllerApiFp(this.configuration).getStudentApplicationsUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return the requested student.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public getStudentUsingGET(id: number, options?: any) {
        return StudentControllerApiFp(this.configuration).getStudentUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Enroll a student in the platform.
     * @param {StudentDTOReq} student student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public registerStudentUsingPOST(student: StudentDTOReq, options?: any) {
        return StudentControllerApiFp(this.configuration).registerStudentUsingPOST(student, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Change a Student\'s CV
     * @param {number} id id
     * @param {CVReq} cv cv
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public updateCVUsingPUT(id: number, cv: CVReq, options?: any) {
        return StudentControllerApiFp(this.configuration).updateCVUsingPUT(id, cv, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update student information.
     * @param {SafeStudentDTOReq} student student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentControllerApi
     */
    public updateStudentUsingPUT(student: SafeStudentDTOReq, options?: any) {
        return StudentControllerApiFp(this.configuration).updateStudentUsingPUT(student, options).then((request) => request(this.axios, this.basePath));
    }
}


